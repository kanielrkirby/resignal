---
interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en" class="bg-neutral-900 text-white text-opacity-90">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Astro description" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body>
    <header></header>
    <div class="flex h-full">
      <div class="flex h-full">
        <nav
          id="conversations"
          class="@container flex h-full flex-col items-center gap-1 overflow-y-scroll bg-zinc-800 p-2"
        >
        </nav>
        <div
          data-resize-sidebar-handle
          class="h-full w-3 cursor-ew-resize"
        >
        <div class="w-[.5px] bg-white opacity-30 h-full">
        </div>
        </div>
      </div>
      <main class="h-full w-full resize-x">
        <slot />
      </main>
    </div>
  </body>
</html>

<style>
  html,
  body {
    height: 100%;
  }
</style>

<script>
  import "../store/messages";
  import { $conversations } from "../store/conversations";
  import type { Conversation } from "../store/conversations";
  import { timeSince } from "../utils/timeSince";
  import { AvatarColorMap } from "../types/Colors";
  const conversationsList = document.querySelector("#conversations")!;
  type Conversations = Record<string, Conversation>;

  const handle = document.querySelector("[data-resize-sidebar-handle]") as HTMLElement;
  const hook = document.querySelector("#conversations") as HTMLElement
  const savedWidth = parseInt(localStorage.getItem("sidebar-width") || "300") ?? 300;
  hook.style.width = `${savedWidth}px`

  let minWidth: number | undefined = undefined
  let maxWidth: number | undefined = undefined

  const resize = (e: MouseEvent) => {
    e.preventDefault();
    minWidth = 300
    maxWidth = 380
    let width = e.clientX;
    if (minWidth !== undefined && maxWidth !== undefined) {
      if (width < 100) width = 96
      else if (width > maxWidth) width = maxWidth
      else if (width < minWidth) width = minWidth
      hook!.style.width = `${width}px`;
    }
    document.addEventListener(
      "mouseup",
      () => {
        localStorage.setItem("sidebar-width", width.toString());
        document.removeEventListener("mousemove", resize);
      },
      { once: true },
    );
  };

  function resizer() {
    document.addEventListener("mousemove", resize);
  }

  handle.addEventListener("mousedown", resizer);

  $conversations.subscribe((conversations: Conversations) => {
    conversationsList.innerHTML = "";
    conversationsList.innerHTML = `<h1 id="chats" class="font-semibold text-white @[100px]:bg-opacity-0 bg-opacity-40 bg-white @[100px]:w-full w-2/3 rounded-full p-[1px] my-2"><span class="hidden p-2 @[100px]:block">Chats</span></h1>` + conversationsList.innerHTML;
    conversationsList.innerHTML += `
    <button id="archived-button" class="w-full py-6 opacity-70 gap-2 hover:bg-opacity-10 bg-white bg-opacity-0 rounded-md flex justify-center items-center">
      <img src="/icons/archive.svg" class="h-full" />
      <h1 class="font-bold w-fit h-fit text-sm">Archived Chats</h1>
      <span id="archived-count" class="w-4 h-4 bg-white bg-opacity-10 text-white text-sm p-3 rounded-full flex justify-center items-center">0</span>
    </button>`
    const entries = Object.entries(conversations);
    let pinnedSectionExists = false;
    for (let i = 0; i < entries.length; i++) {
      const conversation = entries[i][1];
      if (conversation.isPinned) {
        if (!pinnedSectionExists) {
          conversationsList.innerHTML = `<h1 id="pinned" class="font-semibold text-white @[100px]:bg-opacity-0 bg-opacity-40 bg-white @[100px]:w-full w-2/3 rounded-full p-[1px] my-2"><span class="hidden p-2 @[100px]:block">Pinned</span></h1>` + conversationsList.innerHTML;
          pinnedSectionExists = true;
        }
      }
      let imgSrc: string | undefined = undefined;
      if (conversation.profileAvatar) {
        const pathSplit = conversation.profileAvatar.path.split("/")[1];
        const isSvg = pathSplit.endsWith(".svg");
        imgSrc = `${location.origin}/${
          isSvg ? "icons" : "attachments"
        }/${pathSplit}${isSvg ? "" : ".jpeg"}`;
      }
      console.log(imgSrc);
      const element = `<a href="/conversation/${
        conversation.id
      }" class="w-full gap-3 bg-white px-4 py-2 rounded-lg flex justify-between items-center ${
        location.pathname.split("/")[
          location.pathname.split("/").length - 1
        ] === conversation.id
          ? "bg-opacity-10"
          : "bg-opacity-0 hover:bg-opacity-5"
      }"]>
        ${
          imgSrc
            ? `<img src="${imgSrc}" class="w-12 h-12 rounded-full" />`
            : `<div data-colors="${
                conversation.color || "null"
              }" class="flex justify-center items-center text-xl w-12 shrink-0 h-12 rounded-full">${
                (conversation.conversationTitle &&
                  conversation.conversationTitle[0]) ||
                "N"
              }</div>`
        }
        <div class="flex flex-col w-full overflow-x-hidden">
          <div class="flex justify-between w-full">
            <h1 class="font-semibold text-[.90rem] text-ellipses">
            ${conversation.conversationTitle}
            </h1>
            
            ${
              (conversation?.lastMessage &&
                conversation?.timestamp &&
                `<span class="opacity-70 text-xs whitespace-nowrap">
                  ${timeSince(conversation?.timestamp) ?? ""}
              </span>`) ||
              ""
            }
          </div>
          <div class="flex gap-2 w-full">
            <p class="opacity-70 text-[.82rem] text-ellipsis w-full h-[2.5rem] [display:-webkit-box] [-webkit-line-clamp:2] [-webkit-box-orient:vertical]">
              ${conversation.lastMessage || "No messages yet"}
            </p>
            ${
              conversation?.lastMessage
                ? `<img src="${location.origin}/icons/messagestatus-${
                    conversation.lastMessageStatus?.toLowerCase() ?? "read"
                  }.svg" class="w-4 h-fit opacity-70" />`
                : ""
            }
          </div>
        </div>
      </a>`;
      if (conversation.isPinned) {
        document.querySelector("#pinned")!.insertAdjacentHTML(
          "afterend",
          element,
        );
      }
      else if (conversation.isArchived) {
        const count = document.querySelector("#archived-count")!;
        count.innerHTML = (parseInt(count.innerHTML) + 1).toString();
        document.querySelector("#archived-button")!.insertAdjacentHTML(
          "afterend",
          element,
        );
      } else {
        document.querySelector("#chats")!.insertAdjacentHTML(
          "afterend",
          element,
        );
      }
    }
    const colorables = document.querySelectorAll(
      "[data-colors]",
    ) as NodeListOf<HTMLElement>;

    //     new Map([
    //  [
    //    'A100',
    //    {
    //      bg: '#e3e3fe',
    //      fg: '#3838f5',
    //    },
    //  ],
    //  [
    //    'A110',
    //    {
    //      bg: '#dde7fc',
    //      fg: '#1251d3',
    //    },
    //  ],
    //  ])
    for (let i = 0; i < colorables.length; i++) {
      const colorable = colorables[i];
      const color = colorable.getAttribute("data-colors") as string;
      const colors = AvatarColorMap.get(color);
      if (color === "null" || colors === undefined) {
        colorable.style.backgroundColor = "#111";
        colorable.style.color = "#fff";
      } else {
        colorable.style.backgroundColor = colors?.bg;
        colorable.style.color = colors?.fg;
      }
    }
  });
</script>
